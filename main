;	+----+----+----+
;	| 11 | 10 |  9 |	row3
;	+----+----+----+
;	|  8 |  7 |  6 |	row2
;	+----+----|----+
;	|  5 |  4 |  3 |	row1
;	+----+----+----+
;	|  2 |  1 |  0 |	row0
;	+----+----+----+
;	 col2 col1 col0

;|--------------------------------------------------------------------------------------|
;|linha 1 | 00 | 01 | 02 | 03 | 04 |05 | 06 | 07 | 08 | 09 |0A | 0B | 0C | 0D | 0E | 0F |
;|linha 2 | 40 | 41 | 42 | 43 | 44 |45 | 46 | 47 | 48 | 49 |4A | 4B | 4C | 4D | 4E | 4F |
;|--------------------------------------------------------------------------------------|

; 1 - ligar
; 2 - sensor de �gua
; 3 - sensor da c�psula
; 4 - caf� pequeno
; 5 - caf� m�dio
; 6 - caf� grande
; switch 2 = erro 5
; switch 3 = erro 29

; Alterar o switch 0 para o p3.2

RS equ P1.3
EN equ P1.2

org 0000h
	LJMP MAIN

org 0003h
	INT_0:
    		CPL P1.0  ; Inverte o estado de P1.0 (pode ser um LED, por exemplo)
    		RETI      ; Retorna da interrup��o

org 0013h
	INT_1:
    		CPL P1.0  ; Inverte o estado de P1.0 (pode ser um LED, por exemplo)
    		RETI      ; Retorna da interrup��o

org 0030h
	; DEFINICAO DOS TEXTOS UTILIZADOS
	msgIniciarParte1: 
		DB "Pressione o"
		DB 00H
	msgIniciarParte2: 
		DB "botao 1"
		DB 00H
	msgTamanhoCafeParte1:
		DB "Selecione o cafe"
		DB 00H
	msgTamanhoCafeParte2: 
		DB "P-4 M-5 G-6"
		DB 00H
	msgSelecionado: 
		DB "selecionado"
		DB 00H
	selecaoCafe4: 
		DB "Caf� pequeno"
		DB 00H 
	selecaoCafe5: 
		DB "Caf� medio"
		DB 00H
	selecaoCafe6: 
		DB "Caf� grande"
		DB 00H 
	fazendoCafe4Parte1: 
		DB "Fazendo cafe"
		DB 00H
	fazendoCafe4Parte2: 
		DB "pequeno"
		DB 00H
	fazendoCafe5Parte1: 
		DB "Fazendo cafe"
		DB 00H
	fazendoCafe5Parte2: 
		DB "medio"
		DB 00H
	fazendoCafe6Parte1: 
		DB "Fazendo cafe"
		DB 00H
	fazendoCafe6Parte2: 
		DB "grande"
		DB 00H
	ErroBotao2: 
		DB "Erro 05"
		DB 00H
	ErroBotao3: 
		DB "Erro 29"
		DB 00H

org #0100h
	MAIN:
		ACALL lcd_init
	  	ACALL iniciar
		ACALL menuSelecao
		MOV A, #6
	  	ACALL piscaLed
	  	SETB P1.7
	  	ACALL selecionaCafe
	
	iniciar:
		ACALL menuInicio
		ESPERAINICIAR:
		  	CLR F0
			ACALL leituraTeclado
			JNB F0, ROTINA   ;if F0 is clear, jump to ROTINA
		  	CJNE R0, #1, ESPERAINICIAR
		RET

	menuInicio:
		MOV A, #02h
		ACALL POSICIONACURSOR
		MOV DPTR,#msgIniciarParte1
		ACALL ESCREVESTRINGROM
		MOV A, #44h
		ACALL POSICIONACURSOR
		MOV DPTR,#msgIniciarParte2
		ACALL ESCREVESTRINGROM
		RET
	
	MENUSELECAO:
		MOV A, #00h
		ACALL POSICIONACURSOR
		MOV DPTR,#msgTamanhoCafeParte1
		ACALL ESCREVESTRINGROM
		MOV A, #40
		ACALL POSICIONACURSOR
		MOV DPTR,#msgTamanhoCafeParte2
		ACALL ESCREVESTRINGROM
		RET
		
	
	selecionaCafe:
	  	CLR F0
	  	ACALL leituraLinha2
	  	JNB F0, selecionaCafe
	  	CJNE R0, #4, verifica5

	verifica5:
		CJNE R0, #5, verifica6

	verifica6:
		CJNE R0, #6, selecionaCafe

	leituraLinha2:
		MOV R0, #0
	
		; scan row2
		SETB P0.1
		CLR P0.2
		CALL colScan
		JB F0, finish
	
	leituraTeclado:
		MOV R0, #0			; clear R0 - the first key is key0
	
		; scan row2
		SETB P0.1			; set row1
		CLR P0.2			; clear row2
		CALL colScan		; call column-scan subroutine
		JB F0, finish		; | if F0 is set, jump to end of program 
							; | (because the pressed key was found and its number is in  R0)
		; scan row3
		SETB P0.2			; set row2
		CLR P0.3			; clear row3
		CALL colScan		; call column-scan subroutine
		JB F0, finish		; | if F0 is set, jump to end of program 
							; | (because the pressed key was found and its number is in  R0)
	finish:
		RET
	
	; column-scan subroutine
	colScan:
		JNB P0.4, gotKey	; if col0 is cleared - key found
		INC R0				; otherwise move to next key
		JNB P0.5, gotKey	; if col1 is cleared - key found
		INC R0				; otherwise move to next key
		JNB P0.6, gotKey	; if col2 is cleared - key found
		INC R0				; otherwise move to next key
		RET					; return from subroutine - key not found
	gotKey:
		SETB F0				; key found - set F0
		RET					; and return from subroutine
	
	
	
	
	; initialise the display
	; see instruction set for details
	lcd_init:
	
		CLR RS		; clear RS - indicates that instructions are being sent to the module
	
	; function set	
		CLR P1.7		; |
		CLR P1.6		; |
		SETB P1.5		; |
		CLR P1.4		; | high nibble set
	
		SETB EN		; |
		CLR EN		; | negative edge on E
	
		CALL delay		; wait for BF to clear	
						; function set sent for first time - tells module to go into 4-bit mode
	; Why is function set high nibble sent twice? See 4-bit operation on pages 39 and 42 of HD44780.pdf.
	
		SETB EN		; |
		CLR EN		; | negative edge on E
						; same function set high nibble sent a second time
	
		SETB P1.7		; low nibble set (only P1.7 needed to be changed)
	
		SETB EN		; |
		CLR EN		; | negative edge on E
					; function set low nibble sent
		CALL delay		; wait for BF to clear
	
	
	; entry mode set
	; set to increment with no shift
		CLR P1.7		; |
		CLR P1.6		; |
		CLR P1.5		; |
		CLR P1.4		; | high nibble set
	
		SETB EN		; |
		CLR EN		; | negative edge on E
	
		SETB P1.6		; |
		SETB P1.5		; |low nibble set
	
		SETB EN		; |
		CLR EN		; | negative edge on E
	
		CALL delay		; wait for BF to clear
	
	
	; display on/off control
	; the display is turned on, the cursor is turned on and blinking is turned on
		CLR P1.7		; |
		CLR P1.6		; |
		CLR P1.5		; |
		CLR P1.4		; | high nibble set
	
		SETB EN		; |
		CLR EN		; | negative edge on E
	
		SETB P1.7		; |
		SETB P1.6		; |
		SETB P1.5		; |
		SETB P1.4		; | low nibble set
	
		SETB EN		; |
		CLR EN		; | negative edge on E
	
		CALL delay		; wait for BF to clear
		RET
	
	
	sendCharacter:
		SETB RS  		; setb RS - indicates that data is being sent to module
		MOV C, ACC.7		; |
		MOV P1.7, C			; |
		MOV C, ACC.6		; |
		MOV P1.6, C			; |
		MOV C, ACC.5		; |
		MOV P1.5, C			; |
		MOV C, ACC.4		; |
		MOV P1.4, C			; | high nibble set
	
		SETB EN			; |
		CLR EN			; | negative edge on E
	
		MOV C, ACC.3		; |
		MOV P1.7, C			; |
		MOV C, ACC.2		; |
		MOV P1.6, C			; |
		MOV C, ACC.1		; |
		MOV P1.5, C			; |
		MOV C, ACC.0		; |
		MOV P1.4, C			; | low nibble set
	
		SETB EN			; |
		CLR EN			; | negative edge on E
	
		CALL delay			; wait for BF to clear
		CALL delay			; wait for BF to clear
		RET
	posicionaCursor:
		CLR RS	
		SETB P1.7		    ; |
		MOV C, ACC.6		; |
		MOV P1.6, C			; |
		MOV C, ACC.5		; |
		MOV P1.5, C			; |
		MOV C, ACC.4		; |
		MOV P1.4, C			; | high nibble set
	
		SETB EN			; |
		CLR EN			; | negative edge on E
	
		MOV C, ACC.3		; |
		MOV P1.7, C			; |
		MOV C, ACC.2		; |
		MOV P1.6, C			; |
		MOV C, ACC.1		; |
		MOV P1.5, C			; |
		MOV C, ACC.0		; |
		MOV P1.4, C			; | low nibble set
	
		SETB EN			; |
		CLR EN			; | negative edge on E
	
		CALL delay			; wait for BF to clear
		CALL delay			; wait for BF to clear
		RET
	
	;Limpa o display
	clearDisplay:
		CLR RS	
		CLR P1.7		; |
		CLR P1.6		; |
		CLR P1.5		; |
		CLR P1.4		; | high nibble set
	
		SETB EN		; |
		CLR EN		; | negative edge on E
	
		CLR P1.7		; |
		CLR P1.6		; |
		CLR P1.5		; |
		SETB P1.4		; | low nibble set
	
		SETB EN		; |
		CLR EN		; | negative edge on E
	
		CALL delay		; wait for BF to clear
		RET
	
	
	delay:
		MOV R7, #50
		DJNZ R7, $
		RET
	
	escreveStringROM:
	  MOV R1, #00h
		; Inicia a escrita da String no Display LCD
	loop:
	  MOV A, R1
		MOVC A,@A+DPTR 	 ;lê da memória de programa
		JZ finish		; if A is 0, then end of data has been reached - jump out of loop
		ACALL sendCharacter	; send data in A to LCD module
		INC R1			; point to next piece of data
	   MOV A, R1
		JMP loop		; repeat
	finish:
		RET
